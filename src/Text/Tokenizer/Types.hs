{- |
  Module        : Text.Tokenizer.Types
  Copyright     : (c) Lev Dvorkin, 2022
  License       : MIT
  Maintainer    : lev_135@mail.ru
  Stability     : Experimental

  This module contains common types used by uniqueness checking and
  tokenizing algorithms
-}
module Text.Tokenizer.Types (
    Repeatable (..), getBWS, castRep, castReps,
    TokId (..), Token (..), RToken (..), makeRToken
  ) where

import Data.Function (on)

import Text.Tokenizer.BlackWhiteSet (BlackWhiteSet)

-- | 'BlackWhiteSet' that is/isn't able to be repeated.
--
-- @Repeatable 'False c@ is isomorphic to @c@ (symbol's set can not be repeated).
-- @Repeatable 'True c@ can be repeated
-- (both 'One' and 'Some' constructors can be used).
data Repeatable (r :: Bool) c where
  -- | construct 'Repeatable' matching exactly one character from 'BlackWhiteSet'
  One :: BlackWhiteSet c -> Repeatable r c
  -- | construct 'Repeatable' matching one or more characters from 'BlackWhiteSet'
  Some :: BlackWhiteSet c -> Repeatable 'True c

-- | Returns 'BlackWhiteSet' matchable (one or some times) by 'Repeatable'
getBWS :: Repeatable r c -> BlackWhiteSet c
getBWS = \case
  One bws -> bws
  Some bws -> bws

-- | Reduce restrictions for 'Repeatable' (i. e. it's possible to make it
-- really repeatable (@r' ~ 'True@), even if it's not at the moment)
castRep :: forall r' r c. (r ~ 'True => r' ~ 'True) =>
  Repeatable r c -> Repeatable r' c
castRep = \case
  One x -> One x
  Some x -> Some x

-- | Apply 'castRep' for all repeatables in list:
--
-- prop> castReps == map castRep
castReps :: forall r' r c. (r ~ 'True => r' ~ 'True) =>
  [Repeatable r c] -> [Repeatable r' c]
castReps = map castRep

deriving instance Eq c => Eq (Repeatable r c)
deriving instance Ord c => Ord (Repeatable r c)
deriving instance Show c => Show (Repeatable r c)

-- data TokExp c
--   = ERep (Repeatable 'True c)
--   | ESeq (TokExp c) (TokExp c)
--   | EOr  (TokExp c) (TokExp c)

-- | Token with name of type @k@ (used for uniqueness error messages and
-- tokenizing output) over char type @c@.
data Token k c = Token
  { -- | the name of token
    name:: k,
    -- | restrictions on symbols before/after matchable part
    --
    -- NB! they are assumed to be satisfied if there are no symbols before/after
    -- matched part respectively
    behind, ahead :: [BlackWhiteSet c],
    -- | matchable sequences of char sets with possible repetitions
    body :: [Repeatable 'True c]
  }

-- | Wrapped token id. Should be generated automatically
newtype TokId = TokId Int
  deriving (Show, Eq, Ord, Bounded, Enum, Num, Real, Integral)

-- | Type for internal needs. Contains autogenerated 'tokId' and restrictions
-- behind token are reversed
data RToken c = RToken
  { -- | unique token's id (generated automatically)
    tokId :: TokId,
    -- | constraints on symbols behind/ahead of matchable part
    rbehind, ahead :: [Repeatable 'False c],
    -- | matchable part of string
    body :: [Repeatable 'True c]
  }
  deriving (Show)

-- | Compares by token's id
instance Eq (RToken c) where
  (==) = (==) `on` tokId
-- | Compares by token's id
instance Ord (RToken c) where
  compare = compare `on` tokId

-- | Construct an 'RToken' from 'Token' and its id
makeRToken :: TokId -> Token k c -> RToken c
makeRToken tokId Token{body, behind, ahead} =
  RToken {
    tokId,
    body,
    rbehind = One <$> reverse behind,
    ahead = One <$> ahead
  }
