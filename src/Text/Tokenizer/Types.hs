{- |
  Module        : Text.Tokenizer.Types
  Copyright     : (c) Lev Dvorkin, 2022
  License       : MIT
  Maintainer    : lev_135@mail.ru
  Stability     : Experimental

  This module contains common types used by uniqueness checking and
  tokenizing algorithms
-}
module Text.Tokenizer.Types (
    Count (..), Repeatable (..),
    TokId (..), Token (..), RToken (..), makeRToken
  ) where

import Data.Function (on)

import Text.Tokenizer.BlackWhiteSet (BlackWhiteSet)

data Count = One | Some
  deriving (Eq, Ord, Show)

-- | 'BlackWhiteSet' that is/isn't able to be repeated.
--
-- @Repeatable 'False c@ is isomorphic to @c@ (symbol's set can not be repeated).
-- @Repeatable 'True c@ can be repeated
-- (both 'One' and 'Some' constructors can be used).
data Repeatable c = Repeatable {
    getCnt :: Count,
    getBWS :: BlackWhiteSet c
  } deriving (Eq, Ord, Show)

-- data TokExp c
--   = ERep (Repeatable 'True c)
--   | ESeq (TokExp c) (TokExp c)
--   | EOr  (TokExp c) (TokExp c)

-- | Token with name of type @k@ (used for uniqueness error messages and
-- tokenizing output) over char type @c@.
data Token k c = Token
  { -- | the name of token
    name:: k,
    -- | restrictions on symbols before/after matchable part
    --
    -- NB! they are assumed to be satisfied if there are no symbols before/after
    -- matched part respectively
    behind, ahead :: [BlackWhiteSet c],
    -- | matchable sequences of char sets with possible repetitions
    body :: [Repeatable c]
  }

-- | Wrapped token id. Should be generated automatically
newtype TokId = TokId Int
  deriving (Show, Eq, Ord, Bounded, Enum, Num, Real, Integral)

-- | Type for internal needs. Contains autogenerated 'tokId' and restrictions
-- behind token are reversed
data RToken c = RToken
  { -- | unique token's id (generated automatically)
    tokId :: TokId,
    -- | constraints on symbols behind/ahead of matchable part
    rbehind, ahead :: [Repeatable c],
    -- | matchable part of string
    body :: [Repeatable c]
  }
  deriving (Show)

-- | Compares by token's id
instance Eq (RToken c) where
  (==) = (==) `on` tokId
-- | Compares by token's id
instance Ord (RToken c) where
  compare = compare `on` tokId

-- | Construct an 'RToken' from 'Token' and its id
makeRToken :: TokId -> Token k c -> RToken c
makeRToken tokId Token{body, behind, ahead} =
  RToken {
    tokId,
    body,
    rbehind = Repeatable One <$> reverse behind,
    ahead = Repeatable One <$> ahead
  }
