module Data.Text.Tokenizer.Types (
    Repeatable (..), getBWS, castRep, castReps,
    TokId (..), Token (..), RToken (..), makeRToken
  ) where

import Data.Text.Tokenizer.BlackWhiteSet (BlackWhiteSet)
import Data.Function (on)

data Repeatable (r :: Bool) c where
  One :: BlackWhiteSet c -> Repeatable r c
  Some :: BlackWhiteSet c -> Repeatable 'True c

getBWS :: Repeatable r c -> BlackWhiteSet c
getBWS = \case
  One bws -> bws
  Some bws -> bws

castRep :: forall r' r c. (r ~ 'True => r' ~ 'True) =>
  Repeatable r c -> Repeatable r' c
castRep = \case
  One x -> One x
  Some x -> Some x

castReps :: forall r' r c. (r ~ 'True => r' ~ 'True) =>
  [Repeatable r c] -> [Repeatable r' c]
castReps = map castRep

deriving instance Eq c => Eq (Repeatable r c)
deriving instance Ord c => Ord (Repeatable r c)
deriving instance Show c => Show (Repeatable r c)

-- data TokExp c
--   = ERep (Repeatable 'True c)
--   | ESeq (TokExp c) (TokExp c)
--   | EOr  (TokExp c) (TokExp c)

data Token k c = Token
  { name:: k,
    behind, ahead :: [BlackWhiteSet c],
    body :: [Repeatable 'True c]
  }

-- | Wrapped token id. Should be generated by automatically
newtype TokId = TokId Int
  deriving (Show, Eq, Ord, Bounded, Enum, Num, Real, Integral)

data RToken c = RToken
  { -- | unique token's id (generated automatically)
    tokId :: TokId,
    -- | constraints on symbols behind/ahead of matchable part
    rbehind, ahead :: [Repeatable 'False c],
    -- | matchable part of string
    body :: [Repeatable 'True c]
  }
  deriving (Show)

-- | Compares by token's id
instance Eq (RToken c) where
  (==) = (==) `on` tokId
-- | Compares by token's id
instance Ord (RToken c) where
  compare = compare `on` tokId

makeRToken :: TokId -> Token k c -> RToken c
makeRToken tokId Token{body, behind, ahead} =
  RToken {
    tokId,
    body,
    rbehind = One <$> reverse behind,
    ahead = One <$> ahead
  }
